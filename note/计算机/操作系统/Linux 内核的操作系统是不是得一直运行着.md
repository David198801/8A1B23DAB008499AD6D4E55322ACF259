作者：高鹏
链接：https://www.zhihu.com/question/23561375/answer/25345790
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



当年上我老板的OS课，老板上来就告诉我们，OS不是运行着的代码，而是一堆躺在内存里等着被调用的代码。

内核就是一个由interrupt驱动的程序。这个interrupt可以是一个系统调用（x86下，很多OS的系统调用是靠software interrupt实现的），可以是一个用户程序产生的异常，也可以是一个硬件产生的事件中断。

于是你的问题解决了：一个用户程序运行的时候，Linux就在内存里呆着，等着一个中断的到来。在这个中断的处理过程中，来做“调度”。而一般的时分系统里，都会有个timer interrupt每隔一段时间到来，也就是楼上说的“时间片”。

PS：很多人在认识OS的过程中被大量的artificial concept给困惑了。比如神马进程，线程，调度，micro kernel，monolithic kernel的。从x86架构上来理解OS才是王道。

=================================================================

PS of PS: 把评论粘上来，补充上面的PS，谢 

[@许越](http://www.zhihu.com/people/00cac8fef58a8c5505097dfc01a4706b)

提醒：

因为很多教材在讲os的时候，更喜欢从app的角度来看待os，于是很多时候被各种概念绑架。因为很多例如进城，线程，系统调用这样的东西都是由os在硬件上抽象出来的。站在这些概念上看os，就有点“不识庐山真面目”的感觉。所以我的意思是从硬件的角度看os，反过来理解为何os要抽象出这些概念。站在cpu的角度，理解指令是怎么在cpu上一条一条的运行的。