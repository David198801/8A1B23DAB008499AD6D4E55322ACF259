posix: 启用 c++11/c11多线程功能。 依赖于 libwinpthreads，即使你不直接调用 API，也将分发给 winpthreads 。 使用应用程序分发一个DLL没有什么问题。

win32: 没有C++11多线程功能。

对任何调用 Win32 api或者 pthreads api的代码都不影响。 你可以同时使用。





【异常处理模型：】

异常处理在开发中非常重要，你在开发的过程中，大部分的时间会耗在处理各种异常情况上。

【64位：】

如果你之前选择了 64位，则这里有两个异常处理模型供你选择，seh 是新发明的，而 sjlj 则是古老的。

seh 性能比较好，但不支持 32位。 sjlj 稳定性好，支持 32位。

【32位：】

选择了 32位 后，则可以用 dwarf 和 sjlj 两种异常处理模型。同样的，dwarf 的性能要优于 sjlj ，可以它不支持 64位 。

操作：建议选择 dwarf





转自：

rsreland(瑞兰德) 的个人网站：《⑨也懂系列：MinGW-w64安装教程》著名C/C++编译器GCC的Windows版本





楼上转的东西很拗口，我来说说我的理解，有失实之处请大家指出。

在C++中有 try..throw..catch，当它执行这种结构时，它需要保存现场还原现场，而 sjlj, seh, dwarf 正是实现这类过程的三种方式。

sjlj 全称是 SetJump LongJump，前者设还原点，后者跳到还原点。

seh 是 Borland 公司的，微软买了其专利使用权，它利用了FS段寄存器，将还原点压入，收到异常时弹出。

相较而言，sjlj 是 C 标准库就有的东西，seh 在 2014 年前是有专利的，从性能上说 seh 比 sjlj 快。

dwarf 我是在开源平台 MinGW 见到这名称，因为专利原因 MinGW 以前并不支持 seh，也许是为了保证性能，它又提供了 dwarf 这种方式。